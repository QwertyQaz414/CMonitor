/*
 * The MIT License
 *
 * Copyright 2018 Andrea Vouk.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * This header has been generated by the C4C library https://github.com/QwertyQaz414/C4C
 */

#include <stddef.h> /* for NULL */

#ifndef CMONITOR_C4C_LINKED_LIST_H
#define CMONITOR_C4C_LINKED_LIST_H

/*------------------------------------------------------------------------------
	struct
------------------------------------------------------------------------------*/

typedef struct cm_alloc_map {
	void* block;
	size_t size;
	const char* filename;
	int line;
	struct cm_alloc_map* next;
	struct cm_alloc_map* prev;
} cm_alloc_map;

/*------------------------------------------------------------------------------
	delcarations
------------------------------------------------------------------------------*/

static void cm_map_init		(cm_alloc_map* head);
static void cm_map_add		(cm_alloc_map* head, cm_alloc_map* new_list);
static void cm_map_add_tail	(cm_alloc_map* head, cm_alloc_map* new_list);
static void cm_map_delete	(cm_alloc_map* entry);
static void cm_map_move		(cm_alloc_map* head, cm_alloc_map* list);
static void cm_map_move_tail(cm_alloc_map* head, cm_alloc_map* list);
static void cm_map_splice	(cm_alloc_map* head, cm_alloc_map* list);

/*------------------------------------------------------------------------------
	implementations
------------------------------------------------------------------------------*/

static void cm_map_init(cm_alloc_map* head)
{
	head->next = head;
	head->prev = head;
}

static void cm_map_add(cm_alloc_map* head, cm_alloc_map* new_list)
{
	head->next->prev = new_list;
	new_list->next = head->next;
	new_list->prev = head;
	head->next = new_list;
}

static void cm_map_add_tail(cm_alloc_map* head, cm_alloc_map* new_list)
{
	head->prev = new_list;
	new_list->next = head;
	new_list->prev = head->prev;
	head->prev->next = new_list;
}

static void cm_map_delete(cm_alloc_map* entry)
{
	entry->next->prev = entry->prev;
	entry->prev->next = entry->next;
	entry->next = NULL;
	entry->prev = NULL;
}

static void cm_map_move(cm_alloc_map* head, cm_alloc_map* list)
{
	list->next->prev = list->prev;
	list->prev->next = list->next;
	cm_map_add(head, list);
}

static void cm_map_move_tail(cm_alloc_map* head, cm_alloc_map* list)
{
	list->next->prev = list->prev;
	list->prev->next = list->next;
	cm_map_add_tail(head, list);
}

static void cm_map_splice(cm_alloc_map* head, cm_alloc_map* list)
{
	if (!(list->next == list)) {
		cm_alloc_map* first = list->next;
		cm_alloc_map* last = list->prev;
		cm_alloc_map* at = head->next;
		first->prev = head;
		head->next = first;
		last->next = at;
		at->prev = last;
	}
}

/*------------------------------------------------------------------------------
	macros
------------------------------------------------------------------------------*/

#define c4c_list_is_empty(head) \
	((head)->next == (head))

#define c4c_list_foreach(head, pos) \
	for (pos = (head)->next; pos != (head); pos = pos->next)

#define c4c_list_foreach_backward(head, pos) \
	for (pos = (head)->prev; pos != (head); pos = pos->prev)

#define c4c_list_foreach_safe(head, pos, n) \
	for (pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)

#define c4c_list_foreach_safe_backward(head, pos, n) \
	for (pos = (head)->prev, n = pos->prev; pos != (head); pos = n, n = pos->prev)

#endif /* CMONITOR_C4C_LINKED_LIST_H */
